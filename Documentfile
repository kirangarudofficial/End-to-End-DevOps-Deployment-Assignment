---

# Project Documentation: End-to-End DevOps Deployment of a Flask Application

## Author
**Kiran Garud**  
DevOps Fresher

## 1. Introduction

This document provides a detailed walkthrough of a project designed to demonstrate a complete, automated CI/CD (Continuous Integration/Continuous Deployment) pipeline. The goal was to take a simple Python Flask application from development to a production-ready state on a cloud server, fully automating every step in between.

This project showcases the practical application of core DevOps principles, including Infrastructure as Code, containerization with Docker, version control with Git, and pipeline automation with Jenkins. The final outcome is a robust, repeatable process for deploying application updates with a single push to a Git repository.

## 2. Prerequisites and Initial Setup

The foundation of this project is a cloud-based environment where all tools can be installed and configured. I chose AWS EC2 for its flexibility and industry-wide adoption.

### 2.1. Cloud Infrastructure: AWS EC2 Instance

1.  **Instance Launch**: I launched an EC2 instance from the AWS Management Console.
    *   **Instance Type**: `t2.medium`. This was chosen to provide sufficient resources to run both the Jenkins server and the Docker daemon concurrently without performance issues.
    *   **AMI (Amazon Machine Image)**: Amazon Linux 2 AMI, a stable and well-supported choice.
    *   **Security Group**: Configured with the following inbound rules to allow necessary traffic:
        *   **Port 22 (SSH)**: For secure access to the instance's command line.
        *   **Port 8080 (Custom TCP)**: To access the Jenkins web interface.
        *   **Port 5000 (Custom TCP)**: To access the deployed Flask application.
    *   **Key Pair**: I created and downloaded a `.pem` key file to securely SSH into the instance.

### 2.2. Software Installation on EC2

After connecting to the EC2 instance via SSH, I proceeded to install all the necessary software components.

```bash
# 1. Update the system
sudo yum update -y

# 2. Install Git for version control
sudo yum install -y git

# 3. Install Java (Jenkins dependency)
sudo yum install -y java-1.8.0-openjdk-devel

# 4. Install Python and pip (for the Flask app)
sudo yum install -y python3 python3-pip

# 5. Install Docker
sudo yum install -y docker
sudo systemctl start docker
sudo systemctl enable docker
sudo usermod -a -G docker ec2-user  # Add the current user to the docker group to run docker without sudo
# Log out and log back in for this to take effect

# 6. Install Jenkins
# First, add the Jenkins repository
sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key
# Then, install Jenkins
sudo yum install -y jenkins
sudo systemctl start jenkins
sudo systemctl enable jenkins
```

After installation, I accessed Jenkins for the first time at `http://<EC2-Public-IP>:8080`, completed the initial setup using the administrator password from `/var/lib/jenkins/secrets/initialAdminPassword`, and installed the suggested plugins.

## 3. Application Development and Containerization

With the environment ready, the next step was to create the application and its configuration files. To accelerate this initial phase, I utilized ChatGPT to generate the boilerplate code for a simple Flask application and its corresponding Dockerfile.

### 3.1. Project Structure

The project was organized into a single directory with the following structure:

```
EndToEndProject/
‚îÇ
‚îú‚îÄ‚îÄ app.py               # The main Flask application logic
‚îú‚îÄ‚îÄ requirements.txt     # Python dependencies for the app
‚îú‚îÄ‚îÄ Dockerfile           # Instructions to containerize the app
‚îú‚îÄ‚îÄ Jenkinsfile          # The Jenkins pipeline definition
‚îî‚îÄ‚îÄ README.md            # Project documentation
```

### 3.2. The Flask Application (`app.py`)

A minimal Flask web server was created to respond to a single API endpoint.

*   **File**: `app.py`
```python
from flask import Flask
app = Flask(__name__)

@app.route('/hello')
def hello():
    return "Hello from DevOps ‚Äì Kiran Garud üöÄ"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```
This code starts a web server that listens on all network interfaces (`0.0.0.0`) on port 5000 and returns a simple JSON string when the `/hello` endpoint is accessed.

### 3.3. Dependencies (`requirements.txt`)

The only external dependency is Flask.

*   **File**: `requirements.txt`
```
Flask==2.0.1
```

### 3.4. Dockerizing the Application (`Dockerfile`)

To ensure the application runs consistently anywhere, I created a `Dockerfile` to package it into a container image.

*   **File**: `Dockerfile`
```dockerfile
# Use an official Python runtime as a parent image
FROM python:3.9-slim

# Set the working directory in the container
WORKDIR /app

# Copy the dependencies file and install them
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the application code
COPY . .

# Expose the port the app runs on
EXPOSE 5000

# Define the command to run the application
CMD ["python3", "app.py"]
```

## 4. Version Control with GitHub

With all the application files created locally on the EC2 instance, the next step was to commit them to a Git repository. This serves as the single source of truth for the project's code.

1.  **Create GitHub Repository**: I created a new public repository on my GitHub account: `End-to-End-DevOps-Deployment-Assignment`.
2.  **Initialize Git and Push Code**: I navigated to the project directory on the EC2 instance and executed the following commands:

```bash
git init
git add .
git commit -m "Initial commit: Add Flask app, Dockerfile, and Jenkinsfile"
git branch -M main
git remote add origin https://github.com/kirangarudofficial/End-to-End-DevOps-Deployment-Assignment.git
git push -u origin main
```

## 5. CI/CD Pipeline Implementation with Jenkins

This is the core of the project, where automation is implemented. The Jenkins pipeline is defined declaratively in a `Jenkinsfile`, which is stored in the root of the Git repository.

### 5.1. Jenkins Configuration

Before creating the pipeline, I configured Jenkins:
1.  **Installed Plugins**: Ensured the `Git`, `Pipeline`, `Docker Pipeline`, and `SSH Agent` plugins were installed.
2.  **Added Credentials**:
    *   **Docker Hub**: Added my Docker Hub username and password as a "Username with password" credential with the ID `dockerhub`. This allows Jenkins to securely log in and push images.
    *   **SSH Key for EC2**: Although the pipeline runs on the same EC2 instance, I configured SSH agent to demonstrate a more robust, remote deployment scenario. For this, I generated an SSH key pair on the instance and added the private key to Jenkins credentials.

### 5.2. The Jenkins Pipeline (`Jenkinsfile`)

The `Jenkinsfile` defines all the automated stages of the pipeline. I wrote this file to execute the following logic:

*   **File**: `Jenkinsfile`

```groovy
pipeline {
    agent any

    environment {
        DOCKERHUB_REPO = "kgarud30/devops-flask-app"
    }

    stages {

        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }

        stage('Checkout Code') {
            steps {
                git branch: 'main',
                    url: 'https://github.com/kirangarudofficial/End-to-End-DevOps-Deployment-Assignment.git'
            }
        }

        stage('Build Docker Image') {
            steps {
                sh '''
                echo "===== Checking Docker Installation ====="
                docker --version

                echo "===== Building Docker Image ====="
                sudo docker build -t devops-flask-app .
                '''
            }
        }

        stage('Docker Hub Login') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'dockerhub',
                    usernameVariable: 'DOCKER_USER',
                    passwordVariable: 'DOCKER_PASS'
                )]) {
                    sh '''
                    echo "===== Docker Hub Login ====="
                    echo "$DOCKER_PASS" | sudo docker login -u "$DOCKER_USER" --password-stdin
                    '''
                }
            }
        }

        stage('Tag Docker Image') {
            steps {
                sh '''
                echo "===== Tagging Docker Image ====="
                sudo docker tag devops-flask-app:latest $DOCKERHUB_REPO:latest
                '''
            }
        }

        stage('Push Image to Docker Hub') {
            steps {
                sh '''
                echo "===== Pushing Docker Image to Docker Hub ====="
                sudo docker push $DOCKERHUB_REPO:latest
                '''
            }
        }

        stage('Deploy Application') {
            steps {
                sh '''
                echo "===== Stopping Old Container ====="
                sudo docker stop devops-flask-app || true

                echo "===== Removing Old Container ====="
                sudo docker rm devops-flask-app || true

                echo "===== Pulling Latest Docker Image ====="
                sudo docker pull $DOCKERHUB_REPO:latest

                echo "===== Starting New Container ====="
                sudo docker run -d -p 5000:5000 --name devops-flask-app $DOCKERHUB_REPO:latest

                echo "===== Deployment Successful ====="
                '''
            }
        }
    }

    post {
        success {
            echo "üéâ CI/CD Pipeline executed successfully!"
        }
        failure {
            echo "‚ùå Pipeline failed ‚Äî Check logs."
        }
    }
}


## 6. Deployment and Verification

With the `Jenkinsfile` pushed to GitHub, I created a new "Pipeline" item in Jenkins, pointed it to my GitHub repository, and ran the pipeline.

### 6.1. The Deployment Process

When the pipeline ran, the following happened automatically:
1.  Jenkins pulled the latest code from GitHub.
2.  It built a Docker image named `kgarud30/devops-flask-app:latest`.
3.  It authenticated with Docker Hub and pushed the image to my public repository.
4.  It executed the deployment script on the EC2 instance:
    *   `docker stop ... || true`: This command attempts to stop the running container. The `|| true` ensures the command doesn't fail if no container is running (e.g., on the very first deployment).
    *   `docker rm ... || true`: Similarly, this removes the old container.
    *   `docker pull ...`: Pulls the latest image that was just pushed to Docker Hub.
    *   `docker run ...`: Starts a new container in detached mode (`-d`), mapping port 5000 on the host to port 5000 in the container.
5.  Finally, the validation stage sent a `curl` request to the `/hello` endpoint to confirm the application was running correctly.

### 6.2. Accessing the Application

After the pipeline completed successfully, I opened a web browser and navigated to:

`http://<EC2-Public-IP>:5000/hello`

The browser displayed the expected response: **"Hello from DevOps ‚Äì Kiran Garud üöÄ"**. The Jenkins UI also showed all stages as green, confirming a successful run.

## 7. Conclusion and Key Takeaways

This project was a comprehensive exercise in building a modern DevOps pipeline. I successfully:
*   **Provisioned Infrastructure**: Set up a cloud server from scratch.
*   **Containerized an Application**: Packaged a Python app into a portable Docker image.
*   **Implemented CI/CD**: Created a fully automated pipeline with Jenkins that builds, tests (via validation), and deploys the application on every code change.
*   **Managed Artifacts**: Used Docker Hub as a central repository for the containerized application.

The most significant takeaway was the power of automation. By defining the entire process in code (`Jenkinsfile`, `Dockerfile`), I eliminated manual, error-prone deployment steps and created a reliable, scalable workflow.

## 8. Future Enhancements

This project provides a solid foundation that can be extended with more advanced DevOps practices:
*   **Automated Testing**: Add a dedicated stage to run unit and integration tests on the code before building the Docker image.
*   **Kubernetes Deployment**: Instead of deploying to a single Docker instance on EC2, push the image to a Kubernetes cluster (like Amazon EKS) for better scalability and resilience.
*   **Blue-Green Deployment**: Implement a blue-green deployment strategy to achieve zero-downtime deployments.
*   **Infrastructure as Code (IaC)**: Use a tool like Terraform to define and provision the EC2 instance and its security groups, making the infrastructure setup repeatable and version-controlled.

---
